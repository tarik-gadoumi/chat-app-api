/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var GraphQLIRTransformer = require('../core/GraphQLIRTransformer');

var _require = require('../core/GraphQLSchemaUtils'),
    getRawType = _require.getRawType,
    isClientDefinedField = _require.isClientDefinedField;

var _require2 = require('../core/RelayCompilerError'),
    createCompilerError = _require2.createCompilerError,
    createUserError = _require2.createUserError;

var cachesByNode = new Map();

function clientExtensionTransform(context) {
  cachesByNode = new Map();
  return GraphQLIRTransformer.transform(context, {
    Fragment: traverseDefinition,
    Root: traverseDefinition,
    SplitOperation: traverseDefinition
  });
}

function traverseDefinition(node) {
  var _serverSchema$getType;

  var compilerContext = this.getContext();
  var serverSchema = compilerContext.serverSchema,
      clientSchema = compilerContext.clientSchema;
  var rootType;

  switch (node.kind) {
    case 'Root':
      switch (node.operation) {
        case 'query':
          rootType = serverSchema.getQueryType();
          break;

        case 'mutation':
          rootType = serverSchema.getMutationType();
          break;

        case 'subscription':
          rootType = serverSchema.getSubscriptionType();
          break;

        default:
          node.operation;
      }

      break;

    case 'SplitOperation':
      rootType = serverSchema.getType(node.type.name);
      break;

    case 'Fragment':
      rootType = (_serverSchema$getType = serverSchema.getType(node.type.name)) !== null && _serverSchema$getType !== void 0 ? _serverSchema$getType : clientSchema.getType(node.type.name);
      break;

    default:
      node;
  }

  if (rootType == null) {
    throw createUserError("ClientExtensionTransform: Expected the type of `".concat(node.name, "` to have been defined in the schema. Make sure both server and ") + 'client schema are up to date.', [node.loc]);
  }

  return traverseSelections(node, compilerContext, rootType);
}

function traverseSelections(node, compilerContext, parentType) {
  var nodeCache = cachesByNode.get(node);

  if (nodeCache == null) {
    nodeCache = new Map();
    cachesByNode.set(node, nodeCache);
  }

  var result = nodeCache.get(parentType);

  if (result != null) {
    // $FlowFixMe - TODO: type IRTransformer to allow changing result type
    return result;
  }

  var serverSchema = compilerContext.serverSchema,
      clientSchema = compilerContext.clientSchema;
  var clientSelections = [];
  var serverSelections = cowMap(node.selections, function (selection) {
    switch (selection.kind) {
      case 'ClientExtension':
        throw createCompilerError('Unexpected ClientExtension node before ClientExtensionTransform', [selection.loc]);

      case 'Condition':
      case 'Defer':
      case 'InlineDataFragmentSpread':
      case 'ModuleImport':
      case 'Stream':
        return traverseSelections(selection, compilerContext, parentType);

      case 'ScalarField':
        if (isClientDefinedField(selection, compilerContext, parentType)) {
          clientSelections.push(selection);
          return null;
        } else {
          return selection;
        }

      case 'ConnectionField':
      case 'LinkedField':
        {
          var _serverSchema$getType2;

          if (isClientDefinedField(selection, compilerContext, parentType)) {
            clientSelections.push(selection);
            return null;
          }

          var rawType = getRawType(selection.type);
          var fieldType = (_serverSchema$getType2 = serverSchema.getType(rawType.name)) !== null && _serverSchema$getType2 !== void 0 ? _serverSchema$getType2 : clientSchema.getType(rawType.name);

          if (fieldType == null) {
            throw createCompilerError('ClientExtensionTransform: Expected to be able to determine ' + "type of field `".concat(selection.name, "`."), [selection.loc]);
          }

          return traverseSelections(selection, compilerContext, fieldType);
        }

      case 'InlineFragment':
        {
          var _serverType;

          var typeName = selection.typeCondition.name;
          var serverType = serverSchema.getType(typeName);
          var clientType = clientSchema.getType(typeName);
          var isClientType = serverType == null && clientType != null;

          if (isClientType) {
            clientSelections.push(selection);
            return null;
          }

          var type = (_serverType = serverType) !== null && _serverType !== void 0 ? _serverType : clientType;

          if (type == null) {
            throw createCompilerError('ClientExtensionTransform: Expected to be able to determine ' + "type of inline fragment on `".concat(typeName, "`."), [selection.loc]);
          }

          return traverseSelections(selection, compilerContext, type);
        }

      case 'FragmentSpread':
        {
          var fragment = compilerContext.getFragment(selection.name, selection.loc);
          var _typeName = fragment.type.name;

          var _serverType2 = serverSchema.getType(_typeName);

          var _clientType = clientSchema.getType(_typeName);

          var _isClientType = _serverType2 == null && _clientType != null;

          if (_isClientType) {
            clientSelections.push(selection);
            return null;
          }

          return selection;
        }

      default:
        selection;
        throw createCompilerError("ClientExtensionTransform: Unexpected selection of kind `".concat(selection.kind, "`."), [selection.loc]);
    }
  });

  if (clientSelections.length === 0) {
    if (serverSelections === node.selections) {
      result = node;
    } else {
      result = (0, _objectSpread2["default"])({}, node, {
        selections: serverSelections
      });
    }
  } else {
    result = (0, _objectSpread2["default"])({}, node, {
      selections: [].concat((0, _toConsumableArray2["default"])(serverSelections), [// Group client fields under a single ClientExtension node
      {
        kind: 'ClientExtension',
        loc: node.loc,
        metadata: null,
        selections: clientSelections
      }])
    });
  }

  nodeCache.set(parentType, result); // $FlowFixMe - TODO: type IRTransformer to allow changing result type

  return result;
}
/**
 * Maps an array with copy-on-write semantics.
 * `null` return values from the map function are removals.
 */


function cowMap(selections, f) {
  for (var i = 0; i < selections.length; i++) {
    var prevSelection = selections[i];
    var nextSelection = f(prevSelection);

    if (prevSelection !== nextSelection) {
      var result = selections.slice(0, i);

      if (nextSelection != null) {
        result.push(nextSelection);
      }

      for (var j = i + 1; j < selections.length; j++) {
        var innerNextSelection = f(selections[j]);

        if (innerNextSelection != null) {
          result.push(innerNextSelection);
        }
      }

      return result;
    }
  } // nothing changed, return original


  return selections;
}

module.exports = {
  transform: clientExtensionTransform
};